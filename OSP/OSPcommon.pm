#
# "THE BEER-WARE LICENSE" (Revision 42):
# <luisdecameixa@coit.es> wrote this file. As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return Luis Diaz Gonzalez
#

# Utiliza como BD el fichero creado con el siguiente scritp para WinFIOL
# @@@ Crea BBDD 2G (BSC, Cells) de OSP
# eac_esi_config -nelist | grep '.*B[1-9]' | sort | uniq
# @unset {_line0}
# @size {_lines} {nBSC}
# @FOREACH {_lines} ITEM {BSC[{_CURRIDX}]} {_LINES[{_CURRIDX}]} " " 0
# @set {i} = 1
# @size {_lines} {nBSC}
# @log on OSP2GDB.txt
# @foreach {BSC} @gosub CHECKBSC
# @L-
# @exit

# @label CHECKBSC
# @if {i}={nBSC} then return
# eaw {BSC[{i}]}
# rxtcp:moty=rxotg;
# @T 2
# exit;
# @inc {i}
# @return
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
      

package OSPcommon;
use strict;
use warnings;
use diagnostics -verbose;
use String::Strip;    # 35% faster than the regex methods.

our @EXPORT_OK = qw(ltrim rtrim trim fltrim frtrim ftrim RemoveMultipleElem GenerateDBfromWinFIOL SeekBSCTG);

# left trim
sub ltrim { my $s = shift; $s =~ s/^\s+//; return $s }

# right trim
sub rtrim { my $s = shift; $s =~ s/\s+$//; return $s }

# trim space (left and right)
sub trim { my $s = shift; $s =~ s/^\s+|\s+$//g; return $s }

# left trim
sub fltrim { my $s = shift; StripLSpace($s); return $s }

# right trim
sub frtrim { my $s = shift; StripTSpace($s); return $s }

# trim space (left and right)
sub ftrim { my $s = shift; StripLTSpace($s); return $s }

sub RemoveMultipleElem {
    my $refin = shift;
    my %h     = ();
    my @ret   = grep { !$h{$_}++ if ( defined $_ ) } @$refin;
    return \@ret;
}

# GenerateDB: Input-> file : 2G DB created by WinFIOL script. Output-> DB (hash)
# Read file generated by WinFIOL to create a DB (hash) (bsc, tg, cells)
sub GenerateDBfromWinFIOL {

    # Read OSP 2G DB RAW
    open my $fileRAW, '<', "$_[0]"
      or die "Couldn't open file file.txt, $!";

    my ( $BSC, $tg, %hp );
    while (<$fileRAW>) {

        chomp;
        if ( $_ =~ /eaw/ ) {
            $_ =~ /^.*eaw\s(.*)$/;
            $BSC = trim($1);

            #print $BSC;
        }

        if ( $_ =~ /^RXOTG-.*/ ) {

            $_ =~ /^RXOTG-(\d+).\s(.+).\s.+$/;
            $tg = $1;
            push @{ $hp{$BSC}{$tg} }, trim($2);
            ##print " ".$tg." $2 "."\n";
        }

        if ( $_ !~ /^RXOTG-.*/ ) {
            if ( $_ !~ /eaw/ ) {
                $_ =~ /^.\s(.+).\s[01]$/;
                push @{ $hp{$BSC}{$tg} }, trim($1) if ( defined $1 );
            }
        }
    }

    close $fileRAW;
    return \%hp;
}

# SeekSite : Inputs-> %h (DB), $site. Output-> @bsc, @tg
sub SeekBSCTG {
    if ( length $_[1] != 7 ) { return ( undef, undef ) }
    my %h          = %{ $_[0] };
    my $site       = $_[1];
    my $comunidad  = substr( $site, 0, 3 );
    my $code       = substr( $site, 3, 4 );
    my $prefixsite = undef;

    for ($comunidad) {
        /ARA/ and do { $prefixsite = 'R'; last; };
        /AST/ and do { $prefixsite = 'S'; last; };
        /CTB/ and do { $prefixsite = 'T'; last; };
        /CLM/ and do { $prefixsite = 'X'; last; };
        /CYL/ and do { $prefixsite = 'Z'; last; };
        /CAT/ and do { $prefixsite = 'C'; last; };
        /GAL/ and do { $prefixsite = 'G'; last; };
        /RIO/ and do { $prefixsite = 'J'; last; };
        /MAD/ and do { $prefixsite = 'M'; last; };
        /NAV/ and do { $prefixsite = 'N'; last; };
        /PVA/ and do { $prefixsite = 'P'; last; };
        if ( not defined $prefixsite ) { return ( undef, undef ) }
    }

    $site = $prefixsite . $code;

    my @bsc = ();
    my @tg  = ();

    my @t;
    foreach my $f ( keys %h ) {
        foreach my $g ( keys %{ $h{$f} } ) {
            @t = grep /^$site/, @{ $h{$f}{$g} };

            #print "$f  $g\n" if ( (defined $t[0]) and ($t[0] ne '0') );
            push @bsc, $f if ( ( defined $t[0] ) and ( $t[0] ne '0' ) );
            push @tg,  $g if ( ( defined $t[0] ) and ( $t[0] ne '0' ) );

        }
        @t = undef;
    }
    return ( \@bsc, \@tg );
}
1;
